//! Patroni post-bootstrap script
//!
//! Runs ONCE after PostgreSQL initialization on the primary node.
//! Patroni 4.0+ removed bootstrap.users, so users must be created here.
//!
//! IMPORTANT: Patroni runs this as a subprocess WITHOUT environment variables.
//! We MUST read credentials from /tmp/patroni.yml (generated by patroni-runner)
//!
//! Patroni passes:
//!   $1 = connection string URL (e.g., postgres://user@localhost:5432/postgres)
//!   PGPASSFILE = path to pgpass file for authentication

use anyhow::{anyhow, Context, Result};
use postgres_patroni::{extract_yaml_value, volume_root};
use std::env;
use std::path::Path;
use std::process::{Command, Stdio};
use tracing::{error, info};

const PATRONI_CONFIG: &str = "/tmp/patroni.yml";

struct Credentials {
    repl_user: String,
    repl_pass: String,
    superuser: String,
    superuser_pass: String,
    app_user: String,
    app_pass: String,
    app_db: String,
}

fn read_credentials() -> Result<Credentials> {
    let content =
        std::fs::read_to_string(PATRONI_CONFIG).context("Failed to read Patroni config")?;

    // Extract credentials from YAML
    // The structure has nested sections like:
    //   authentication:
    //     replication:
    //       username: xxx
    //       password: xxx

    let repl_user = extract_nested_value(&content, "authentication", "replication", "username")
        .ok_or_else(|| anyhow!("Could not extract replication username"))?;
    let repl_pass = extract_nested_value(&content, "authentication", "replication", "password")
        .ok_or_else(|| anyhow!("Could not extract replication password"))?;
    let superuser = extract_nested_value(&content, "authentication", "superuser", "username")
        .ok_or_else(|| anyhow!("Could not extract superuser username"))?;
    let superuser_pass = extract_nested_value(&content, "authentication", "superuser", "password")
        .ok_or_else(|| anyhow!("Could not extract superuser password"))?;

    // app_user is a direct section under postgresql
    let app_user = extract_yaml_value(&content, "app_user", "username").unwrap_or_default();
    let app_pass = extract_yaml_value(&content, "app_user", "password").unwrap_or_default();
    let app_db = extract_yaml_value(&content, "app_user", "database").unwrap_or_default();

    Ok(Credentials {
        repl_user,
        repl_pass,
        superuser,
        superuser_pass,
        app_user,
        app_pass,
        app_db,
    })
}

/// Extract a value from deeply nested YAML like:
///   section1:
///     section2:
///       key: value
fn extract_nested_value(
    content: &str,
    section1: &str,
    section2: &str,
    key: &str,
) -> Option<String> {
    let mut in_section1 = false;
    let mut in_section2 = false;
    let mut section1_indent = 0;
    let mut section2_indent = 0;

    for line in content.lines() {
        let trimmed = line.trim_start();
        let indent = line.len() - trimmed.len();

        // Look for section1
        if trimmed.starts_with(&format!("{}:", section1)) {
            in_section1 = true;
            section1_indent = indent;
            continue;
        }

        if in_section1 {
            // Check if we left section1
            if !trimmed.is_empty() && indent <= section1_indent && !trimmed.starts_with('#') {
                in_section1 = false;
                in_section2 = false;
                continue;
            }

            // Look for section2
            if trimmed.starts_with(&format!("{}:", section2)) {
                in_section2 = true;
                section2_indent = indent;
                continue;
            }

            if in_section2 {
                // Check if we left section2
                if !trimmed.is_empty() && indent <= section2_indent && !trimmed.starts_with('#') {
                    in_section2 = false;
                    continue;
                }

                // Look for key
                if trimmed.starts_with(&format!("{}:", key)) {
                    return postgres_patroni::parse_yaml_value(trimmed);
                }
            }
        }
    }

    None
}

fn run_psql(superuser: &str, sql: &str) -> Result<String> {
    // Use env -i to run psql with a completely clean environment
    let output = Command::new("env")
        .args(["-i"])
        .env("PATH", env::var("PATH").unwrap_or_default())
        .args([
            "psql",
            "-v",
            "ON_ERROR_STOP=1",
            "-h",
            "/var/run/postgresql",
            "-U",
            superuser,
            "-d",
            "postgres",
            "-c",
            sql,
        ])
        .stdin(Stdio::null())
        .output()
        .context("Failed to run psql")?;

    if output.status.success() {
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    } else {
        Err(anyhow!(
            "psql failed: {}",
            String::from_utf8_lossy(&output.stderr)
        ))
    }
}

fn run_psql_script(superuser: &str, sql: &str) -> Result<String> {
    let mut child = Command::new("env")
        .args(["-i"])
        .env("PATH", env::var("PATH").unwrap_or_default())
        .args([
            "psql",
            "-v",
            "ON_ERROR_STOP=1",
            "-h",
            "/var/run/postgresql",
            "-U",
            superuser,
            "-d",
            "postgres",
        ])
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .context("Failed to spawn psql")?;

    use std::io::Write;
    if let Some(mut stdin) = child.stdin.take() {
        stdin.write_all(sql.as_bytes())?;
    }

    let output = child.wait_with_output()?;

    if output.status.success() {
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    } else {
        Err(anyhow!(
            "psql failed: {}",
            String::from_utf8_lossy(&output.stderr)
        ))
    }
}

fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive(tracing::Level::INFO.into()),
        )
        .with_target(false)
        .init();

    info!("Post-bootstrap: starting...");

    if !Path::new(PATRONI_CONFIG).exists() {
        error!("ERROR: Patroni config not found at {}", PATRONI_CONFIG);
        std::process::exit(1);
    }

    let creds = read_credentials()?;

    if creds.repl_user.is_empty() || creds.repl_pass.is_empty() {
        error!("ERROR: Could not extract replication credentials from Patroni config");
        std::process::exit(1);
    }

    if creds.superuser.is_empty() {
        error!("ERROR: Could not extract superuser from Patroni config");
        std::process::exit(1);
    }

    info!(
        "Post-bootstrap: setting up users (connecting as {})...",
        creds.superuser
    );

    // Build SQL script
    // Use format() for ALL password operations to ensure proper escaping
    let sql = format!(
        r#"
-- Ensure SCRAM-SHA-256 is used (DCS config may not be applied yet)
SET password_encryption = 'scram-sha-256';

-- Set password for the superuser (already exists from initdb)
DO $$
BEGIN
    EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', '{superuser}', '{superuser_pass}');
    RAISE NOTICE 'Set password for superuser: {superuser}';
END
$$;

-- Create or update replication user
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '{repl_user}') THEN
        EXECUTE format('CREATE ROLE %I WITH REPLICATION LOGIN PASSWORD %L', '{repl_user}', '{repl_pass}');
        RAISE NOTICE 'Created replication user: {repl_user}';
    ELSE
        EXECUTE format('ALTER ROLE %I WITH REPLICATION LOGIN PASSWORD %L', '{repl_user}', '{repl_pass}');
        RAISE NOTICE 'Updated replication user: {repl_user}';
    END IF;
END
$$;

-- Create or update app user if different from superuser
DO $$
BEGIN
    IF '{app_user}' = '{superuser}' THEN
        RAISE NOTICE 'App user same as superuser, skipping';
    ELSIF '{app_user}' = '' OR '{app_pass}' = '' THEN
        RAISE NOTICE 'App user not configured, skipping';
    ELSIF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '{app_user}') THEN
        EXECUTE format('CREATE ROLE %I WITH LOGIN PASSWORD %L', '{app_user}', '{app_pass}');
        RAISE NOTICE 'Created app user: {app_user}';
    ELSE
        EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', '{app_user}', '{app_pass}');
        RAISE NOTICE 'Updated app user: {app_user}';
    END IF;
END
$$;

-- Create postgres superuser for compatibility (many tools expect this user)
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'postgres') THEN
        EXECUTE format('CREATE ROLE postgres WITH SUPERUSER LOGIN PASSWORD %L', '{superuser_pass}');
        RAISE NOTICE 'Created postgres superuser for compatibility';
    ELSE
        ALTER ROLE postgres WITH SUPERUSER;
        RAISE NOTICE 'Ensured postgres has superuser privileges';
    END IF;
END
$$;
"#,
        superuser = creds.superuser,
        superuser_pass = creds.superuser_pass,
        repl_user = creds.repl_user,
        repl_pass = creds.repl_pass,
        app_user = creds.app_user,
        app_pass = creds.app_pass,
    );

    run_psql_script(&creds.superuser, &sql)?;

    // Create app database if configured
    if !creds.app_db.is_empty() && creds.app_db != "postgres" {
        info!("Post-bootstrap: checking app database {}...", creds.app_db);

        let db_exists = run_psql(
            &creds.superuser,
            &format!(
                "SELECT 1 FROM pg_database WHERE datname = '{}'",
                creds.app_db
            ),
        )?;

        if !db_exists.contains('1') {
            info!("Post-bootstrap: creating app database {}...", creds.app_db);
            run_psql(
                &creds.superuser,
                &format!("CREATE DATABASE \"{}\"", creds.app_db),
            )?;
            info!("Post-bootstrap: created app database {}", creds.app_db);
        } else {
            info!(
                "Post-bootstrap: app database {} already exists",
                creds.app_db
            );
        }

        // Grant privileges
        if !creds.app_user.is_empty() && creds.app_user != creds.superuser {
            let grant_sql = format!(
                r#"
DO $$
BEGIN
    EXECUTE format('GRANT ALL PRIVILEGES ON DATABASE %I TO %I', '{db}', '{user}');
    RAISE NOTICE 'Granted privileges on {db} to {user}';
END
$$;
"#,
                db = creds.app_db,
                user = creds.app_user,
            );
            run_psql_script(&creds.superuser, &grant_sql)?;
        }
    }

    info!(
        "Post-bootstrap: users created (superuser: {}, replication: {}, app: {}, database: {})",
        creds.superuser, creds.repl_user, creds.app_user, creds.app_db
    );

    // Mark bootstrap as complete
    let marker_path = format!("{}/.patroni_bootstrap_complete", volume_root());
    std::fs::write(&marker_path, "").context("Failed to write bootstrap marker")?;

    info!("Post-bootstrap: completed successfully");

    Ok(())
}
